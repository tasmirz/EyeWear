<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>WebSocket Media Viewer</title>
		<style>
			body { font-family: sans-serif; margin: 0; padding: 16px; }
			#videoCanvas { background: #000; width: 640px; height: 480px; }
		</style>
	</head>
	<body>
		<h3>WebSocket Media Viewer</h3>
		<canvas id="videoCanvas" width="640" height="480"></canvas>
		<p id="status">Connecting...</p>

		<script>
			const statusEl = document.getElementById('status');
			const canvas = document.getElementById('videoCanvas');
			const ctx = canvas.getContext('2d');
			const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws?role=viewer';

			const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

			const ws = new WebSocket(wsUrl);
			ws.binaryType = 'arraybuffer';

			ws.onopen = () => {
				statusEl.textContent = 'Connected as viewer';
			};

			ws.onclose = () => { statusEl.textContent = 'Disconnected'; };

			ws.onerror = (e) => { console.error('ws error', e); statusEl.textContent = 'WebSocket error'; };

			function playPcm16(pcm16Array, sr, channels) {
				// convert Int16Array to Float32Array
				const float32 = new Float32Array(pcm16Array.length);
				for (let i = 0; i < pcm16Array.length; i++) {
					float32[i] = pcm16Array[i] / 32768.0;
				}

				// create audio buffer (mono or stereo)
				const frames = float32.length / channels;
				const audioBuffer = audioCtx.createBuffer(channels, frames, sr);
				if (channels === 1) {
					audioBuffer.getChannelData(0).set(float32);
				} else {
					// deinterleave
					for (let ch = 0; ch < channels; ch++) {
						const chan = audioBuffer.getChannelData(ch);
						for (let i = 0; i < frames; i++) {
							chan[i] = float32[i * channels + ch];
						}
					}
				}

				const src = audioCtx.createBufferSource();
				src.buffer = audioBuffer;
				src.connect(audioCtx.destination);
				src.start();
			}

			ws.onmessage = async (evt) => {
				// try text -> JSON
				if (typeof evt.data === 'string') {
					let parsed;
					try {
						parsed = JSON.parse(evt.data);
					} catch (e) {
						console.warn('non-json text', evt.data);
						return;
					}

					if (parsed.type === 'video' && parsed.jpeg_b64) {
						const img = new Image();
						img.onload = () => {
							// draw centered
							const cw = canvas.width, ch = canvas.height;
							const iw = img.width, ih = img.height;
							const scale = Math.min(cw / iw, ch / ih);
							const w = iw * scale, h = ih * scale;
							ctx.fillStyle = 'black'; ctx.fillRect(0,0,cw,ch);
							ctx.drawImage(img, (cw - w) / 2, (ch - h) / 2, w, h);
						};
						img.src = 'data:image/jpeg;base64,' + parsed.jpeg_b64;
						return;
					}

					if (parsed.type === 'audio' && parsed.pcm_b64) {
						// decode base64 to ArrayBuffer
						const binStr = atob(parsed.pcm_b64);
						const len = binStr.length;
						const bytes = new Uint8Array(len);
						for (let i = 0; i < len; i++) bytes[i] = binStr.charCodeAt(i);
						// interpret as Int16
						const pcm16 = new Int16Array(bytes.buffer);
						playPcm16(pcm16, parsed.sr || 16000, parsed.ch || 1);
						return;
					}
				} else if (evt.data instanceof ArrayBuffer) {
					// not used in our protocol, but could be handled
					console.warn('binary message received');
				}
			};
		</script>
	</body>
</html>
